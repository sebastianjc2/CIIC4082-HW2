#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Names:   Sebast,Kevin,Jeremy,Sebast    names spelled in column
INDEX0_H db 0xB7, 0x0E, 0x78, 0xB7      ; S, K, J, S
INDEX0_L db 0x00, 0x22, 0x00, 0x00

INDEX1_H db 0x9F, 0x9F, 0x9F, 0x9F      ; E, E, E, E
INDEX1_L db 0x00, 0x00, 0x00, 0x00
  
INDEX2_H db 0xF1, 0x0C, 0xCF, 0xF1      ; B, V, R, B
INDEX2_L db 0x50, 0x28, 0x02, 0x50

INDEX3_H db 0xEF, 0x90, 0x9F, 0xEF      ; A, I, E, A
INDEX3_L db 0x00, 0x50, 0x00, 0x00

INDEX4_H db 0xB7, 0x6C, 0x6C, 0xB7      ; S, N, M, S
INDEX4_L db 0x00, 0x82, 0xA0, 0x00

INDEX5_H db 0x80, 0x00, 0x00, 0x80      ; T,  , Y, T
INDEX5_L db 0x50, 0x00, 0xB0, 0x50

;Signed or unsigned letters:
;             S    U
SorU_H   db 0xB7, 0x7C
SorU_L   db 0x00, 0x00

;Conversion Answer Letters (Y/N): 
;             Y    N        
YESNO_H  db 0x00, 0x6C
YESNO_L  db 0xB0, 0x82

;Decimal spaces answers:
;             1     2
Dspace_H db 0x60, 0xDB 
Dspace_L db 0x20, 0x00 

;Digits    0      1     2     3    4     5     6     7      8     9
digitsH db 0xFC, 0X60, 0XDB, 0XF3, 0x67, 0XB7, 0XBF, 0Xe0, 0XFF, 0XF7
digitsL db 0X28, 0X20, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack       


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

unlockGPIO:
        bic.w   #LOCKLPM5, &PM5CTL0
        
setupDisplayAndPorts:     
        ; Manage Ports
        mov.b #11111001B, &P1DIR        ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        bic.b #BIT0,&P1OUT              ; set P1.0 LED off (annoying)

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD magic
        mov #0x041e,&LCDCCTL0           ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL          ; enable voltage for display
        mov #0x8000, &LCDCCPCTL         ; enable clock synchronization
        mov #2, &LCDCMEMCTL             ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0               ; turn the LCD on

	call	#SetUp
        call    #titleScreen
        call    #displayNamesLoopCall
        call    #displaySignedScreenLoopCall
        call    #askConversion
        call    #HowManySelection
        call    #enterNumber
        call    #programEnd
        
;================================================================================
SetUp:
	mov	#2,LCDCMEMCTL
        mov     #0,R6   ; used for registering button presses
        mov     #0,R7   ; used for delay purposes
        mov     #0,R8   ; used for indexing through arrays
        mov     #0,R9
	ret  
;================================================================================
; F(P.Q)
titleScreen: 
        mov.b #0x8E, &0xA29 ; F 
        mov.b #0x22, &0xA26 ; (
        mov.b #0xCF, &0xA23 ; P
        mov.b #0x01, &0xA24 ; .
        mov.b #0xFC, &0xA32 ; Q
        mov.b #0x02, &0xA33 ; Q (inner line)
        mov.b #0x88, &0xA2F ; )
        push.w R5 ; store original register value
        jmp titleScreenInput 

titleScreenInput: ; check s1.1 button presses
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     titleScreenDelay
        jmp     titleScreenInput
        
titleScreenDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal again to check if it was really pressed
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; it's no longer pressed and no long presses
        jeq     titleScreenInput        ; if S1 was NOT released after being pressed or wasn't really pressed correctly
        pop     R6
        mov     #2, &LCDCMEMCTL         ; clear screen
        ret
        
        
;============================================================================        
displayNamesLoopCall:
        push.w  R6                      ; used for button presses
        push.w  R8                      ; used for indexing names
        mov     #0,R8                   ; start at the first name
        jmp     displayNames

displayNames:
        mov     #2,LCDCMEMCTL
        cmp.b   #4, R8
        jeq     resetNameIndex
        mov.b   INDEX0_H (R8), &0xA29
        mov.b   INDEX0_L (R8), &0xA2A
        mov.b   INDEX1_H (R8), &0xA25
        mov.b   INDEX1_L (R8), &0xA26
        mov.b   INDEX2_H (R8), &0xA23
        mov.b   INDEX2_L (R8), &0xA24
        mov.b   INDEX3_H (R8), &0xA32
        mov.b   INDEX3_L (R8), &0XA33
        mov.b   INDEX4_H (R8), &0xA2E
        mov.b   INDEX4_L (R8), &0xA2F
        mov.b   INDEX5_H (R8), &0xA27
        mov.b   INDEX5_L (R8), &0xA28
        inc     R8
        jmp     displayNamesLoop        

resetNameIndex:
        clr     R8
        jmp     displayNames
        
displayNamesLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     displayNamesDelay 
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6          ; if S2 was pressed 
        jeq     releasedS2InDisplayNames         ;S2 was Pressed 
        jmp     displayNamesLoop        ; wasn't released

displayNamesDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if still holding it down: 
        jeq     displayNamesLoop        ; go back, keep checking for input
        jmp     displayNames            ; if it was released: then display next name

releasedS2InDisplayNames:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     displayNamesLoop        ; if still pressed, keep checking for input
        jmp     endDisplayNames         ; if released, stop displaying names. Go to next menu
 
endDisplayNames:
        pop     R8
        pop     R6
        mov     #2,LCDCMEMCTL
        ret
;===============================================================================
displaySignedScreenLoopCall:
        mov.b   #0xB7, &0xA29 ; S
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0x7C, &0xA23 ; U 
        mov.b   #0x00, &0xA24 ; 
        mov.b   #0xC1, &0xA32 ;?
        mov.b   #0x10, &0xA33
        mov.b   #0xB7, &0xA27
        mov.b   #0x00, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     signedInputLoop

signedInputLoop:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R6     
        and.b #00000110B, R6 ; bit mask on S1.1/2
        cmp.b #00000100B, R6 ; if S1.1 is pressed
        jeq signedS1P1Debounce
        mov.b &P1IN,R6
        and.b #00000110B, R6
        cmp.b #00000010B, R6 ; if S1.2 is pressed
        jeq signedS1P2Debounce
        jmp signedInputLoop ; continue to cycle for input

signedS1P1Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000100B,R6
        jeq     signedInputLoop                 ; if still pressed, keep checking
        jmp     SignedOrUnsignedCall            ; both operations for the signed subroutines end the same
        
signedS1P2Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6                   ; if still pressed
        jeq     signedInputLoop
        jmp     signedEnd                       ; both operations for the signed subroutines end the same

SignedOrUnsignedCall:
        mov.b   #0x00, &0xA27                   ; clear the S (default value)
        mov.b   #0x00, &0xA28
        jmp     SignedOrUnsigned
       
SignedOrUnsigned:
        cmp.b   #2,R8
        jeq     resetSignedIndex
        mov.b   SorU_H(R8),&0xA27
        mov.b   SorU_L(R8),&0xA28
        inc     R8
        jmp     signedInputLoop

resetSignedIndex:
        clr     R8
        jmp     SignedOrUnsigned
        
signedEnd:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;===============================================================================        
askConversion:
        mov.b   #0xF0, &0xA29           ;D
        mov.b   #0x50, &0xA2A
        mov.b   #0x00, &0xA25           ;>
        mov.b   #0x88, &0xA26
        mov.b   #0xF1, &0xA23           ;B
        mov.b   #0x50, &0xA24
        mov.b   #0xC1, &0xA32           ;?
        mov.b   #0x10, &0xA33
        mov.b   #0x00, &0xA2E
        mov.b   #0x00, &0xA2F
        mov.b   #0x00, &0xA27
        mov.b   #0xB0, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8 
        jmp     askConversionLoop
        
askConversionLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     askConversionDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InAskConversion          ;S2 was Pressed
        jmp     askConversionLoop        ; wasn't released

askConversionDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6
        jeq     askConversionLoop
        jmp     askConversionCall
        ret

releasedS2InAskConversion:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     askConversionLoop
        jmp     endAskConversion

askConversionCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     askConversionYN
        
askConversionYN:
        cmp.b   #2,R8
        jeq     resetIndex
        mov.b   YESNO_H(R8), &0xA27     ; Clear the N that was default value
        mov.b   YESNO_L(R8), &0xA28
        inc     R8
        jmp     askConversionLoop
        
resetIndex:
        clr     R8
        jmp     askConversionYN
        
endAskConversion:
        mov     R8,R4
        pop     R8
        pop     R6
        mov     #2,&LCDCMEMCTL
        ret       
;===================================================================================
HowManySelection:
        cmp     #0,R4
        jeq     displayBinaryQuantityCall
        cmp     #1,R4
        jeq     askDecimalSpacesCall
        cmp     #2,R4
        jeq     displayBinaryQuantityCall

askDecimalSpacesCall:
        call    #askDecimalSpaces
        mov     #2,LCDCMEMCTL
        ret
        
displayBinaryQuantityCall:
        call    #displayBinaryQuantity
        mov     #2,LCDCMEMCTL
        ret
        
;HowManyEnd:
;        mov     #2,LCDCMEMCTL
;        ret
        
;====================================================================================
askDecimalSpaces:
        mov.b   #0x60, &0xA29; 1
        mov.b   #0x20, &0xA2A ; 1 (inner line)
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0xDB, &0xA23 ; 2
        mov.b   #0xCB, &0xA32 ; ?
        mov.b   #0x60, &0xA27
        mov.b   #0x20, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     decimalLoop

decimalLoop:
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6          ; check if you touched S1
        jeq     decimalDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InDecimal      ;check here if s2 wa pressed
        jmp     decimalLoop             ; loopyagain

decimalDelay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6
        jeq     decimalLoop
        jmp     decimalCall
        
releasedS2InDecimal:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     decimalLoop
        jmp     endDecimalSpace


decimalCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     decimalOneTwo

decimalOneTwo:
        cmp.b   #2, R8
        jeq     resetDecIndex
        mov.b   Dspace_H(R8), &0xA27 ;1 | 2
        mov.b   Dspace_L(R8), &0xA28
        inc     R8
        jmp     decimalLoop

resetDecIndex:
        clr     R8
        jmp     decimalOneTwo
        
endDecimalSpace:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;=========================================================================================
; BITS A

displayBinaryQuantity: 
        mov.b  #0xF1, &0xa29   ;B
        mov.b  #0x50, &0xA2A   ;B
        mov.b  #0x90, &0xa25   ;I
        mov.b  #0x50, &0xa26   ;I
        mov.b  #0x80, &0xa23   ;T
        mov.b  #0x50, &0xa24   ;T
        mov.b  #0xB7, &0xa32   ;S
        mov.b  #0xC1, &0xA2E   ;?
        mov.b  #0x10, &0xA2F   ;?
        mov.b  #0xFC, &0xA27 ; 0 (default option)
        mov.b  #0x00, &0xA28 ; 
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     quantityLoop

quantityLoop:  
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6           ; check if you touched S1
        jeq     BitsS1P1Delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     BitsS1P2Delay            ;check here if s2 wa pressed
        jmp     quantityLoop             ; loopyagain

BitsS1P1Delay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6
        jeq     quantityLoop
        jmp     BitsCall
        ret                             ; just to test
        
BitsS1P2Delay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     quantityLoop
        jmp     endAskQuantity

BitsCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     choosingQuantity
        
choosingQuantity: 
        cmp.b   #7,R8
        jeq     resetBitsIndex
        mov.b   digitsH(R8),&0xA27
        mov.b   digitsL(R8),&0xA28 
        INC     R8
        jmp     quantityLoop
        
resetBitsIndex:
        clr     R8
        jmp     choosingQuantity
        
endAskQuantity:
        mov     #2,&LCDCMEMCTL
        pop     R8
        pop     R6
        ret
;==========================================================================================

; Subroutine for selection of decimal or binary number to convert. 

enterNumber:
        CMP.b #4,&P1IN 
        MOV.W #2 , &LCDCMEMCTL ;CLEAR LCD
        mov.b #0xFC,&0xa25   ; 0
        mov.b #0xFC,&0xa23   ; 0
        mov.b #0x01, &0xa24  ; .
        mov.b #0xFC,&0xa32   ; 0
        mov.b #0xFC,&0xa2e   ; 0
        mov.b #0xFC, &0xa27  ; 0

checkSign:;Check which sign was selected. 
        JEQ enterValue1

enterValue1:   ; Enter first value from left to right between 0-9.
        mov.b #0, R11
loopNumber1:  
        call #delay
        CMP.b #2,&P1IN 
        JEQ enterValue2

        mov.b digitsH(R11),&0xa25
        mov.b digitsL(R11),&0xa26 
        
        CMP.b #4,&P1IN 
        JEQ incrementR11        
        JMP loopNumber1
        
incrementR11: 
        INC R11
        CMP.b #10,R11 
        JEQ enterValue1   
        JMP loopNumber1

        
enterValue2:   ; Enter second value from left to right between 0-9.
        mov.b #0, R12
loopNumber2:  call #delay
        CMP.b #2,&P1IN 
        JEQ enterValue3
        
        mov.b digitsH(R12),&0xa23
        mov.b digitsL(R12),&0xa24
        bis.b #0x01,&0xa24
        
        CMP.b #4,&P1IN 
        JEQ increment12        
        JMP loopNumber2
        
increment12: 
       INC R12
       CMP.b #10,R12
       JEQ enterValue2   
       JMP loopNumber2


enterValue3:   ; Enter third value from left to right between 0-9.
        mov.b #0, R13
loopNumber3:  
        call #delay
        CMP.b #2,&P1IN 
        JEQ enterValue4
        
        mov.b digitsH(R13),&0xa32
        mov.b digitsL(R13),&0xa33 
  
        
        CMP.b #4,&P1IN 
        JEQ incrementR13       
        JMP loopNumber3
        
incrementR13: 
       INC R13
        CMP.b #10,R13 
        JEQ enterValue3   
        JMP loopNumber3
        
enterValue4:   ; Enter fourth value from left to right between 0-9.
        mov.b #0, R14
loopNumber4:  
        call #delay
        CMP.b #2,&P1IN 
        JEQ enterValue5
        
        mov.b digitsH(R14),&0xa2e
        mov.b digitsL(R14),&0xa2f 
  
        
        CMP.b #4,&P1IN 
        JEQ incrementR14       
        JMP loopNumber4
        
incrementR14: 
        INC R14
        CMP.b #10,R14 
        JEQ enterValue4   
        JMP loopNumber4
       
enterValue5:   ; Enter fith value from left to right between 0-9.
        mov.b #0, R15
loopNumber5:  
        call #delay
        CMP.b #2,&P1IN 
        JEQ endEnterNumber
        
        mov.b digitsH(R15),&0xa27
        mov.b digitsL(R15),&0xa28  
        CMP.b #4,&P1IN 
        JEQ incrementR15       
        JMP loopNumber5
        
incrementR15: 
        INC R15
        CMP.b #10,R15 
        JEQ enterValue5   
        JMP loopNumber5
        
endEnterNumber:

        mov     #2,&LCDCMEMCTL
        ret     
       
;==============================================================================
        
delay:
        push.w  R7
        call    #delay2
        pop     R7
        ret
        
delay2:
        mov     #0xffff,R7
        jmp     next2
next2:
        dec     R7
        jnz     next2
        ret
        
programEnd:
        mov     #2, &LCDCMEMCTL
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        END