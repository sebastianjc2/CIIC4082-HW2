#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Names:   Sebast,Kevin,Jeremy,Sebast    names spelled in column
INDEX0_H db 0xB7, 0x0E, 0x78, 0xB7      ; S, K, J, S
INDEX0_L db 0x00, 0x22, 0x00, 0x00

INDEX1_H db 0x9F, 0x9F, 0x9F, 0x9F      ; E, E, E, E
INDEX1_L db 0x00, 0x00, 0x00, 0x00
  
INDEX2_H db 0xF1, 0x0C, 0xCF, 0xF1      ; B, V, R, B
INDEX2_L db 0x50, 0x28, 0x02, 0x50

INDEX3_H db 0xEF, 0x90, 0x9F, 0xEF      ; A, I, E, A
INDEX3_L db 0x00, 0x50, 0x00, 0x00

INDEX4_H db 0xB7, 0x6C, 0x6C, 0xB7      ; S, N, M, S
INDEX4_L db 0x00, 0x82, 0xA0, 0x00

INDEX5_H db 0x80, 0x00, 0x00, 0x80      ; T,  , Y, T
INDEX5_L db 0x50, 0x00, 0xB0, 0x50

;Conversion Answer Letters (Y/N): 
;             Y    N        
YESNO_H  db 0x00, 0x6C
YESNO_L  db 0xB0, 0x82

;Signed or unsigned letters:
;             S    U
SorU_H   db 0xB7, 0x7C
SorU_L   db 0x00, 0x00

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack       

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

unlockGPIO:
        bic.w   #LOCKLPM5, &PM5CTL0
        
setupDisplayAndPorts:     
        ; Manage Ports
        mov.b #11111001B, &P1DIR        ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        bic.b #BIT0,&P1OUT              ; set P1.0 LED off (annoying)

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD magic
        mov #0x041e,&LCDCCTL0           ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL          ; enable voltage for display
        mov #0x8000, &LCDCCPCTL         ; enable clock synchronization
        mov #2, &LCDCMEMCTL             ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0               ; turn the LCD on



	call	#SetUp
        call    #titleScreen
        mov     #0,R8
        call    #displayNames
        mov     #1,R8
        call    #displaySignedScreenLoopCall
        mov     #1,R8
        call    #askConversion 
        call    #programEnd
        
;================================================================================
SetUp:
        mov.b   #00000000B, &0xA29
        mov.b   #00000000B, &0xA2A
        mov.b   #00000000B, &0xA25
        mov.b   #00000000B, &0xA26
        mov.b   #00000000B, &0xA23
        mov.b   #00000000B, &0xA24
        mov.b   #00000000B, &0xA32
        mov.b   #00000000B, &0XA33
        mov.b   #00000000B, &0xA2E
        mov.b   #00000000B, &0xA2F
        mov.b   #00000000B, &0xA27
        mov.b   #00000000B, &0xA28
	mov	#2,LCDCMEMCTL
	ret  
;================================================================================
; F(P.Q)
titleScreen: 
        mov.b #0x8E, &0xA29 ; F 
        mov.b #0x22, &0xA26 ; (
        mov.b #0xCF, &0xA23 ; P
        mov.b #0x01, &0xA24 ; .
        mov.b #0xFC, &0xA32 ; Q
        mov.b #0x02, &0xA33 ; Q (inner line)
        mov.b #0x88, &0xA2F ; )
        push.w R5 ; store original register value
        jmp titleScreenInput 

titleScreenInput: ; check s1.1 button presses
        mov.b   &P1IN, R5               ; copy value of the input signal  
        and.b   #00000110B, R5          ; bit mask on S1.1
        cmp.b   #00000100B, R5          ; if S1 was pressed (sets to 0 when pressed)
        jeq     titleScreenDelay
        jmp     titleScreenInput
        
titleScreenDelay:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN, R5               ; copy value of the input signal again to check if it was really pressed
        and.b   #00000110B, R5          ; bit mask on S1.1
        cmp.b   #00000100B, R5          ; it's no longer pressed and no long presses
        jeq     titleScreenInput        ; if S1 was NOT released after being pressed or wasn't really pressed correctly
        pop     R5
        mov     #2, &LCDCMEMCTL         ; clear screen
        ret
        
        
;============================================================================        
displayNamesLoopCall:
        push.w  R6
        call    #displayNamesLoop
        pop     R6
        ret
        
displayNamesLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     displayNamesDelay 
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InDisplayNames         ;S2 was Pressed
        
        jmp     displayNamesLoop        ; wasn't released

displayNamesDelay:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6
        jeq     displayNamesLoop
        jmp     displayNamesCall
        mov     #2, &LCDCMEMCTL         ; why here?
        ret

releasedS2InDisplayNames:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     displayNamesLoop
        jmp     endDisplayNames

displayNamesCall:
        push.w  R8
        call    #displayNames
        pop     R8
        ret
        
displayNames:
        ;It depends on the content of R8 wich will contain a number from ;0 - 5 representing each name
        cmp.b   #4, R8
        jeq     resetNameIndex
        mov.b   INDEX0_H (R8), &0xA29
        mov.b   INDEX0_L (R8), &0xA2A
        mov.b   INDEX1_H (R8), &0xA25
        mov.b   INDEX1_L (R8), &0xA26
        mov.b   INDEX2_H (R8), &0xA23
        mov.b   INDEX2_L (R8), &0xA24
        mov.b   INDEX3_H (R8), &0xA32
        mov.b   INDEX3_L (R8), &0XA33
        mov.b   INDEX4_H (R8), &0xA2E
        mov.b   INDEX4_L (R8), &0xA2F
        mov.b   INDEX5_H (R8), &0xA27
        mov.b   INDEX5_L (R8), &0xA28
        inc     R8
        jmp     displayNamesLoop        
        
resetNameIndex:
        clr     R8
        jmp     displayNames
        
endDisplayNames:
        mov     #2,LCDCMEMCTL
        ret
;===============================================================================
displaySignedScreenLoopCall:
        mov.b #0xB7, &0xA29 ; S
        mov.b #0x28, &0xA26 ; /
        mov.b #0x7C, &0xA23 ; U 
        mov.b #0x00, &0xA24 ; 
        mov.b #0xC1, &0xA32 ;?
        mov.b #0x10, &0xA33
        mov.b #0xB7, &0xA27
        mov.b #0x00, &0xA28
        push.w  R6
        call    #signedInputLoop
        pop     R6
        ret

signedInputLoop:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R6     
        and.b #00000110B, R6 ; bit mask on S1.1/2
        cmp.b #00000100B, R6 ; if S1.1 is pressed
        jeq signedS1P1Debounce
        mov.b &P1IN,R6
        and.b #00000110B, R6
        cmp.b #00000010B, R6 ; if S1.2 is pressed
        jeq signedS1P2Debounce
        jmp signedInputLoop ; continue to cycle for input

signedS1P1Debounce:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000100B,R6
        jeq     signedInputLoop             ; if still pressed, keep checking
        setn ; set negative flag -> 1, indicating user wants signed operations
        jmp     SignedOrUnsignedCall ; both operations for the signed subroutines end the same
        mov     #2,LCDCMEMCTL
        ret        
        
signedS1P2Debounce:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6           ; if still pressed
        jeq     signedInputLoop
        clrn 
        jmp signedEnd ; both operations for the signed subroutines end the same

SignedOrUnsignedCall:
        push.w  R8
        mov.b #0x0C, &0xA27     ; clear the U (default value)
        mov.b #0x00, &0xA28
        call    #SignedOrUnsigned
        pop     R8
        ret
       
SignedOrUnsigned:
        cmp.b   #2,R8
        jeq     resetSignedIndex
        mov.b   SorU_H(R8),&0xA27
        mov.b   SorU_L(R8),&0xA28
        inc     R8
        jmp     signedInputLoop

resetSignedIndex:
        clr     R8
        jmp     SignedOrUnsigned
        

signedEnd:
        mov #2, &LCDCMEMCTL
        ret



;===============================================================================        
askConversion:
        mov.b   #0xF0, &0xA29           ;D
        mov.b   #0x50, &0xA2A
        mov.b   #0x00, &0xA25           ;>
        mov.b   #0x88, &0xA26
        mov.b   #0xF1, &0xA23           ;B
        mov.b   #0x50, &0xA24
        mov.b   #0xC1, &0xA32           ;?
        mov.b   #0x10, &0xA33
        mov.b   #0x00, &0xA2E
        mov.b   #0x00, &0xA2F
        mov.b   #0x00, &0xA27
        mov.b   #0xB0, &0xA28
        push.w  R6
        jmp     askConversionLoop
        
askConversionLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     askConversionDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InAskConversion          ;S2 was Pressed
        jmp     askConversionLoop        ; wasn't released

askConversionDelay:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6
        jeq     askConversionLoop
        jmp     askConversionCall
        mov     #2, &LCDCMEMCTL         ; why here?
        ret

releasedS2InAskConversion:
        push.w  R7
        call    #delay
        pop     R7
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     askConversionLoop
        jmp     endAskConversion

askConversionCall:
        push.w  R8
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        call    #askConversionYN
        pop     R8
        jmp     endAskConversion
        
askConversionYN:
        cmp.b   #2,R8
        jeq     resetIndex
        mov.b   YESNO_H(R8), &0xA27     ; Clear the N that was default value
        mov.b   YESNO_L(R8), &0xA28
        inc     R8
        jmp     askConversionLoop
        
resetIndex:
        clr     R8
        jmp     askConversionYN
        
endAskConversion:
        pop     R6
        mov     #2,&LCDCMEMCTL
        ret       
        
        
        
        
        
        
        
delay:
        push.w  R7
        call    #delay2
        pop     R7
        ret
delay2:
        mov     #0xffff,R7       
next:
        dec     R7
        jnz     next
        ret
        

        
programEnd:
        mov     #2, &LCDCMEMCTL
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        END
