#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Names:   Sebast,Kevin,Jeremy,Sebast    names spelled in column
INDEX0_H db 0xB7, 0x0E, 0x78, 0xB7      ; S, K, J, S
INDEX0_L db 0x00, 0x22, 0x00, 0x00

INDEX1_H db 0x9F, 0x9F, 0x9F, 0x9F      ; E, E, E, E
INDEX1_L db 0x00, 0x00, 0x00, 0x00
  
INDEX2_H db 0xF1, 0x0C, 0xCF, 0xF1      ; B, V, R, B
INDEX2_L db 0x50, 0x28, 0x02, 0x50

INDEX3_H db 0xEF, 0x90, 0x9F, 0xEF      ; A, I, E, A
INDEX3_L db 0x00, 0x50, 0x00, 0x00

INDEX4_H db 0xB7, 0x6C, 0x6C, 0xB7      ; S, N, M, S
INDEX4_L db 0x00, 0x82, 0xA0, 0x00

INDEX5_H db 0x80, 0x00, 0x00, 0x80      ; T,  , Y, T
INDEX5_L db 0x50, 0x00, 0xB0, 0x50

;Signed or unsigned letters:
;             S    U
SorU_H   db 0xB7, 0x7C
SorU_L   db 0x00, 0x00

;Conversion Answer Letters (Y/N): 
;             Y    N        
YESNO_H  db 0x00, 0x6C
YESNO_L  db 0xB0, 0x82

;Decimal spaces answers:
;             1     2
Dspace_H db 0x60, 0xDB 
Dspace_L db 0x20, 0x00 

;Digits    0      1     2     3    4     5     6     7      8     9
digitsH db 0xFC, 0X60, 0XDB, 0XF3, 0x67, 0XB7, 0XBF, 0Xe0, 0XFF, 0XF7
digitsL db 0X00, 0X20, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00

;Bits       0     1 
bitsH   db 0xFC, 0x60
bitsL   db 0x00, 0x20

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack       


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

unlockGPIO:
        bic.w   #LOCKLPM5, &PM5CTL0
        
setupDisplayAndPorts:     
        ; Manage Ports
        mov.b #11111001B, &P1DIR        ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        bic.b #BIT0,&P1OUT              ; set P1.0 LED off (annoying)

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD magic
        mov #0x041e,&LCDCCTL0           ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL          ; enable voltage for display
        mov #0x8000, &LCDCCPCTL         ; enable clock synchronization
        mov #2, &LCDCMEMCTL             ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0               ; turn the LCD on

	call	#SetUp
        call    #titleScreen
        call    #displayNamesLoopCall
        call    #displaySignedScreenLoopCall
        call    #askConversion
        call    #BitsOrDecimalSelection
        call    #programEnd
        
;================================================================================
SetUp:
	mov	#2,LCDCMEMCTL
        mov     #0,R6   ; used for registering button presses
        mov     #0,R7   ; used for delay purposes
        mov     #0,R8   ; used for indexing through arrays
        mov     #0,R9
	ret  
;================================================================================
; F(P.Q)
titleScreen: 
        mov.b #0x8E, &0xA29 ; F 
        mov.b #0x22, &0xA26 ; (
        mov.b #0xCF, &0xA23 ; P
        mov.b #0x01, &0xA24 ; .
        mov.b #0xFC, &0xA32 ; Q
        mov.b #0x02, &0xA33 ; Q (inner line)
        mov.b #0x88, &0xA2F ; )
        push.w R5 ; store original register value
        jmp titleScreenInput 

titleScreenInput: ; check s1.1 button presses
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     titleScreenDelay
        jmp     titleScreenInput
        
titleScreenDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal again to check if it was really pressed
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000110B, R6          ; it's no longer pressed and no long presses
        jne     titleScreenInput        ; (if not released go back) if S1 was NOT released after being pressed or wasn't really pressed correctly ?
                                        ;(changed to a jne jump to remove bug when S1 is held down)
        pop     R6
        mov     #2, &LCDCMEMCTL         ; clear screen
        ret
        
        
;============================================================================        
displayNamesLoopCall:
        push.w  R6                      ; used for button presses
        push.w  R8                      ; used for indexing names
        mov     #0,R8                   ; start at the first name
        jmp     displayNames

displayNames:
        mov     #2,LCDCMEMCTL
        cmp.b   #4, R8
        jeq     resetNameIndex
        mov.b   INDEX0_H (R8), &0xA29
        mov.b   INDEX0_L (R8), &0xA2A
        mov.b   INDEX1_H (R8), &0xA25
        mov.b   INDEX1_L (R8), &0xA26
        mov.b   INDEX2_H (R8), &0xA23
        mov.b   INDEX2_L (R8), &0xA24
        mov.b   INDEX3_H (R8), &0xA32
        mov.b   INDEX3_L (R8), &0XA33
        mov.b   INDEX4_H (R8), &0xA2E
        mov.b   INDEX4_L (R8), &0xA2F
        mov.b   INDEX5_H (R8), &0xA27
        mov.b   INDEX5_L (R8), &0xA28
        inc     R8
        jmp     displayNamesLoop        

resetNameIndex:
        clr     R8
        jmp     displayNames
        
displayNamesLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     displayNamesDelay 
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6          ; if S2 was pressed 
        jeq     releasedS2InDisplayNames         ;S2 was Pressed 
        jmp     displayNamesLoop        ; wasn't released

displayNamesDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000110B, R6          ; (change to check if it was released) if still holding it down: 
        jeq     displayNames            ; (changed to if released display next name)go back, keep checking for input
        jmp     displayNamesLoop        ; (changed to if buttons are not released then loop back) if it was released: then display next name

releasedS2InDisplayNames:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6
        jeq     endDisplayNames          ; if still pressed, keep checking for input
        jmp     displayNamesLoop         ; if released, stop displaying names. Go to next menu
 
endDisplayNames:
        pop     R8
        pop     R6
        mov     #2,LCDCMEMCTL
        ret
;===============================================================================
displaySignedScreenLoopCall:
        mov.b   #0xB7, &0xA29 ; S
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0x7C, &0xA23 ; U 
        mov.b   #0x00, &0xA24 ; 
        mov.b   #0xC1, &0xA32 ;?
        mov.b   #0x10, &0xA33
        mov.b   #0xB7, &0xA27
        mov.b   #0x00, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     signedInputLoop

signedInputLoop:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R6     
        and.b #00000110B, R6 ; bit mask on S1.1/2
        cmp.b #00000100B, R6 ; if S1.1 is pressed
        jeq signedS1P1Debounce
        mov.b &P1IN,R6
        and.b #00000110B, R6
        cmp.b #00000010B, R6 ; if S1.2 is pressed
        jeq signedS1P2Debounce
        jmp signedInputLoop ; continue to cycle for input

signedS1P1Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     SignedOrUnsignedCall            ; (changed to if released) if still pressed, keep checking
        jmp     signedInputLoop                 ; both operations for the signed subroutines end the same
        
signedS1P2Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6                   ; (changed to if released) if still pressed
        jeq     signedEnd
        jmp     signedInputLoop                 ; both operations for the signed subroutines end the same

SignedOrUnsignedCall:
        mov.b   #0x00, &0xA27                   ; clear the S (default value)
        mov.b   #0x00, &0xA28
        jmp     SignedOrUnsigned
       
SignedOrUnsigned:
        cmp.b   #2,R8
        jeq     resetSignedIndex
        mov.b   SorU_H(R8),&0xA27
        mov.b   SorU_L(R8),&0xA28
        inc     R8
        jmp     signedInputLoop

resetSignedIndex:
        clr     R8
        jmp     SignedOrUnsigned
        
signedEnd:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;===============================================================================        
askConversion:
        mov.b   #0xF0, &0xA29           ;D
        mov.b   #0x50, &0xA2A
        mov.b   #0x00, &0xA25           ;>
        mov.b   #0x88, &0xA26
        mov.b   #0xF1, &0xA23           ;B
        mov.b   #0x50, &0xA24
        mov.b   #0xC1, &0xA32           ;?
        mov.b   #0x10, &0xA33
        mov.b   #0x00, &0xA2E
        mov.b   #0x00, &0xA2F
        mov.b   #0x00, &0xA27
        mov.b   #0xB0, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8 
        jmp     askConversionLoop
        
askConversionLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     askConversionDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InAskConversion          ;S2 was Pressed
        jmp     askConversionLoop        ; wasn't released

askConversionDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000110B, R6          ; if S1 released
        jeq     askConversionCall       
        jmp     askConversionLoop       ;otherwise go back
        ret

releasedS2InAskConversion:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6          ;if released end ask conversion       
        jeq     endAskConversion
        jmp     askConversionLoop

askConversionCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     askConversionYN
        
askConversionYN:
        cmp.b   #2,R8
        jeq     resetIndex
        mov.b   YESNO_H(R8), &0xA27     ; Clear the N that was default value
        mov.b   YESNO_L(R8), &0xA28
        inc     R8
        jmp     askConversionLoop
        
resetIndex:
        clr     R8
        jmp     askConversionYN
        
endAskConversion:
        mov     R8,R4
        pop     R8
        pop     R6
        mov     #2,&LCDCMEMCTL
        ret       
;===================================================================================
BitsOrDecimalSelection:
        cmp     #0,R4
        jeq     displayBinaryQuantityCall
        cmp     #1,R4
        jeq     askDecimalSpacesCall
        cmp     #2,R4
        jeq     displayBinaryQuantityCall

askDecimalSpacesCall:
        call    #askDecimalSpaces
        call    #enterNumberSetup
        jmp     BitsOrDecimalEnd
        
displayBinaryQuantityCall:
        call    #displayBinaryQuantity
        call    #enterBitsSetup
        jmp     BitsOrDecimalEnd
        
BitsOrDecimalEnd:
        mov     #2,LCDCMEMCTL
        ret
        
;====================================================================================
askDecimalSpaces:
        mov.b   #0x60, &0xA29; 1
        mov.b   #0x20, &0xA2A ; 1 (inner line)
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0xDB, &0xA23 ; 2
        mov.b   #0xCB, &0xA32 ; ?
        mov.b   #0x60, &0xA27
        mov.b   #0x20, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     decimalLoop

decimalLoop:
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6          ; check if you touched S1
        jeq     decimalDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InDecimal      ;check here if s2 wa pressed
        jmp     decimalLoop             ; loopyagain

decimalDelay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6
        jeq     decimalCall
        jmp     decimalLoop
        
releasedS2InDecimal:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6
        jeq     endDecimalSpace
        jmp     decimalLoop


decimalCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     decimalOneTwo

decimalOneTwo:
        cmp.b   #2, R8
        jeq     resetDecIndex
        mov.b   Dspace_H(R8), &0xA27 ;1 | 2
        mov.b   Dspace_L(R8), &0xA28
        inc     R8
        jmp     decimalLoop

resetDecIndex:
        clr     R8
        jmp     decimalOneTwo
        
endDecimalSpace:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;=========================================================================================
; BITS A

displayBinaryQuantity: 
        mov.b  #0xF1, &0xa29   ;B
        mov.b  #0x50, &0xA2A   ;B
        mov.b  #0x90, &0xa25   ;I
        mov.b  #0x50, &0xa26   ;I
        mov.b  #0x80, &0xa23   ;T
        mov.b  #0x50, &0xa24   ;T
        mov.b  #0xB7, &0xa32   ;S
        mov.b  #0xC1, &0xA2E   ;?
        mov.b  #0x10, &0xA2F   ;?
        mov.b  #0xFC, &0xA27 ; 0 (default option)
        mov.b  #0x00, &0xA28 ; 
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     quantityLoop

quantityLoop:  
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6           ; check if you touched S1
        jeq     BitsS1P1Delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     BitsS1P2Delay            ;check here if s2 wa pressed
        jmp     quantityLoop             ; loopyagain

BitsS1P1Delay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6
        jeq     BitsCall
        jmp     quantityLoop
        ret                             ; just to test
        
BitsS1P2Delay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000110B, R6
        jeq     endAskQuantity
        jmp     quantityLoop

BitsCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     choosingQuantity
        
choosingQuantity: 
        cmp.b   #7,R8
        jeq     resetBitsIndex
        mov.b   digitsH(R8),&0xA27
        mov.b   digitsL(R8),&0xA28 
        INC     R8
        jmp     quantityLoop
        
resetBitsIndex:
        clr     R8
        jmp     choosingQuantity
        
endAskQuantity:
        mov     #2,&LCDCMEMCTL
        pop     R8
        pop     R6
        ret
;==========================================================================================

; Subroutine for selection of decimal number to convert. 
enterNumberSetup:
        MOV.W #2 , &LCDCMEMCTL ;CLEAR LCD
        mov.b #0xFC,&0xa25   ; 0
        mov.b #0xFC,&0xa23   ; 0
        mov.b #0x01, &0xa24  ; .
        mov.b #0xFC,&0xa32   ; 0
        mov.b #0xFC,&0xa2e   ; 0
        mov.b #0xFC, &0xa27  ; 0
        push.w R6
        push.w R8
        mov    #0,R10   ; for the sign
        mov    #1,R11
        mov    #1,R12
        mov    #1,R13
        mov    #1,R14
        mov    #1,R15
        
enterNumber1:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Number1S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Number1S1P2Delay
        jmp     enterNumber1
        
Number1S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopNumber1
        jmp     enterNumber1

Number1S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterNumber2
        jmp     enterNumber1
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopNumber1:  
        CMP.b #10,R11 
        JEQ resetR11
        mov.b digitsH(R11),&0xA25
        mov.b digitsL(R11),&0xA26 
        inc     R11
        jmp     enterNumber1
        
resetR11: 
        clr     R11
        jmp     loopNumber1

        
enterNumber2:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Number2S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Number2S1P2Delay
        jmp     enterNumber2
        
Number2S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopNumber2
        jmp     enterNumber2

Number2S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterNumber3
        jmp     enterNumber2
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopNumber2:  
        CMP.b   #10,R12 
        JEQ     resetR12
        mov.b   digitsH(R12),&0xA23
        mov.b   digitsL(R12),&0xA24 
        bis.b   #0x01,&0xa24
        inc     R12
        jmp     enterNumber2
        
resetR12: 
        clr     R12
        jmp     loopNumber2


enterNumber3:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Number3S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Number3S1P2Delay
        jmp     enterNumber3
        
Number3S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopNumber3
        jmp     enterNumber3

Number3S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterNumber4
        jmp     enterNumber3
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopNumber3:  
        CMP.b   #10,R13 
        JEQ     resetR13
        mov.b   digitsH(R13),&0xA32
        mov.b   digitsL(R13),&0xA33 
        inc     R13
        jmp     enterNumber3
        
resetR13: 
        clr     R13
        jmp     loopNumber3


enterNumber4:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Number4S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Number4S1P2Delay
        jmp     enterNumber4
        
Number4S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopNumber4
        jmp     enterNumber4

Number4S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterNumber5
        jmp     enterNumber4
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopNumber4:  
        CMP.b   #10,R14 
        JEQ     resetR14
        mov.b   digitsH(R14),&0xA2E
        mov.b   digitsL(R14),&0xA2F 
        inc     R14
        jmp     enterNumber4
        
resetR14: 
        clr     R14
        jmp     loopNumber4

enterNumber5:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Number5S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Number5S1P2Delay
        jmp     enterNumber5
        
Number5S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopNumber5
        jmp     enterNumber5

Number5S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     endEnterNumber
        jmp     enterNumber5
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopNumber5:  
        CMP.b   #10,R15 
        JEQ     resetR15
        mov.b   digitsH(R15),&0xA27
        mov.b   digitsL(R15),&0xA28 
        inc     R15
        jmp     enterNumber5
        
resetR15: 
        clr     R15
        jmp     loopNumber5

endEnterNumber:

        mov     #2,&LCDCMEMCTL
        ret     
       
;==============================================================================
; Subroutine for selection of binary number to convert. 
enterBitsSetup:
        MOV.W #2 , &LCDCMEMCTL ;CLEAR LCD
        mov.b #0xFC,&0xA29   ; 0
        mov.b #0xFC,&0xa25   ; 0
        mov.b #0xFC,&0xa23   ; 0
        mov.b #0xFC,&0xa32   ; 0
        mov.b #0xFC,&0xa2e   ; 0
        mov.b #0xFC, &0xa27  ; 0
        push.w R6
        push.w R8
        mov    #1,R10
        mov    #1,R11
        mov    #1,R12
        mov    #1,R13
        mov    #1,R14
        mov    #1,R15
        
enterBit0:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit0S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit0S1P2Delay
        jmp     enterBit0
        
Bit0S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit0
        jmp     enterBit0

Bit0S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterBit1
        jmp     enterBit0
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit0:  
        CMP.b #2,R10 
        JEQ resetR10Bit
        mov.b bitsH(R10),&0xA29
        mov.b bitsL(R10),&0xA2A 
        inc     R10
        jmp     enterBit0
        
resetR10Bit: 
        clr     R10
        jmp     loopBit0        

enterBit1:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit1S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit1S1P2Delay
        jmp     enterBit1
        
Bit1S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit1
        jmp     enterBit1

Bit1S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterBit2
        jmp     enterBit1
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit1:  
        CMP.b #2,R11 
        JEQ resetR11Bit
        mov.b bitsH(R11),&0xA25
        mov.b bitsL(R11),&0xA26 
        inc     R11
        jmp     enterBit1
        
resetR11Bit: 
        clr     R11
        jmp     loopBit1

        
enterBit2:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit2S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit2S1P2Delay
        jmp     enterBit2
        
Bit2S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit2
        jmp     enterBit2

Bit2S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterBit3
        jmp     enterBit2
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit2:  
        CMP.b   #2,R12 
        JEQ     resetR12Bit
        mov.b   bitsH(R12),&0xA23
        mov.b   bitsL(R12),&0xA24 
        inc     R12
        jmp     enterBit2
        
resetR12Bit: 
        clr     R12
        jmp     loopBit2


enterBit3:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit3S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit3S1P2Delay
        jmp     enterBit3
        
Bit3S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit3
        jmp     enterBit3

Bit3S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterBit4
        jmp     enterBit3
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit3:  
        CMP.b   #2,R13 
        JEQ     resetR13Bit
        mov.b   bitsH(R13),&0xA32
        mov.b   bitsL(R13),&0xA33 
        inc     R13
        jmp     enterBit3
        
resetR13Bit: 
        clr     R13
        jmp     loopBit3


enterBit4:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit4S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit4S1P2Delay
        jmp     enterBit4
        
Bit4S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit4
        jmp     enterBit4

Bit4S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     enterBit5
        jmp     enterBit4
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit4:  
        CMP.b   #2,R14 
        JEQ     resetR14Bit
        mov.b   bitsH(R14),&0xA2E
        mov.b   bitsL(R14),&0xA2F 
        inc     R14
        jmp     enterBit4
        
resetR14Bit: 
        clr     R14
        jmp     loopBit4

enterBit5:
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        CMP.b   #00000100B,R6
        jeq     Bit5S1P1Delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6
        jeq     Bit5S1P2Delay
        jmp     enterBit5
        
Bit5S1P1Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     loopBit5
        jmp     enterBit5

Bit5S1P2Delay:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000110B,R6
        jeq     endEnterBit
        jmp     enterBit5
;checkSign:;Check which sign was selected. 
;        JEQ enterValue1

loopBit5:  
        CMP.b   #2,R15 
        JEQ     resetR15Bit
        mov.b   bitsH(R15),&0xA27
        mov.b   bitsL(R15),&0xA28 
        inc     R15
        jmp     enterBit5
        
resetR15Bit: 
        clr     R15
        jmp     loopBit5

endEnterBit:

        mov     #2,&LCDCMEMCTL
        ret     
       
;==============================================================================
        
delay:
        push.w  R7
        call    #delay2
        pop     R7
        ret
        
delay2:
        mov     #0x0fff,R7
        jmp     next2
next2:
        dec     R7
        jnz     next2
        ret
        
programEnd:
        mov     #2, &LCDCMEMCTL
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        END
