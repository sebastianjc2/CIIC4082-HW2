#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Names:   Sebast,Kevin,Jeremy,Sebast    names spelled in column
INDEX0_H db 0xB7, 0x0E, 0x78, 0xB7      ; S, K, J, S
INDEX0_L db 0x00, 0x22, 0x00, 0x00

INDEX1_H db 0x9F, 0x9F, 0x9F, 0x9F      ; E, E, E, E
INDEX1_L db 0x00, 0x00, 0x00, 0x00
  
INDEX2_H db 0xF1, 0x0C, 0xCF, 0xF1      ; B, V, R, B
INDEX2_L db 0x50, 0x28, 0x02, 0x50

INDEX3_H db 0xEF, 0x90, 0x9F, 0xEF      ; A, I, E, A
INDEX3_L db 0x00, 0x50, 0x00, 0x00

INDEX4_H db 0xB7, 0x6C, 0x6C, 0xB7      ; S, N, M, S
INDEX4_L db 0x00, 0x82, 0xA0, 0x00

INDEX5_H db 0x80, 0x00, 0x00, 0x80      ; T,  , Y, T
INDEX5_L db 0x50, 0x00, 0xB0, 0x50

;Signed or unsigned letters:
;             S    U
SorU_H   db 0xB7, 0x7C
SorU_L   db 0x00, 0x00

;Conversion Answer Letters (Y/N): 
;             Y    N        
YESNO_H  db 0x00, 0x6C
YESNO_L  db 0xB0, 0x82

;Decimal spaces answers:
;             1     2
Dspace_H db 0x60, 0xDB 
Dspace_L db 0x20, 0x00   

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack       


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

unlockGPIO:
        bic.w   #LOCKLPM5, &PM5CTL0
        
setupDisplayAndPorts:     
        ; Manage Ports
        mov.b #11111001B, &P1DIR        ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        bic.b #BIT0,&P1OUT              ; set P1.0 LED off (annoying)

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD magic
        mov #0x041e,&LCDCCTL0           ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL          ; enable voltage for display
        mov #0x8000, &LCDCCPCTL         ; enable clock synchronization
        mov #2, &LCDCMEMCTL             ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0               ; turn the LCD on

	call	#SetUp
        call    #titleScreen
        call    #displayNamesLoopCall
        call    #displaySignedScreenLoopCall
        call    #askConversion
        call    #HowManySelection
        call    #programEnd
        
;================================================================================
SetUp:
	mov	#2,LCDCMEMCTL
        mov     #0,R6   ; used for registering button presses
        mov     #0,R7   ; used for delay purposes
        mov     #0,R8   ; used for indexing through arrays
        mov     #0,R9
	ret  
;================================================================================
; F(P.Q)
titleScreen: 
        mov.b #0x8E, &0xA29 ; F 
        mov.b #0x22, &0xA26 ; (
        mov.b #0xCF, &0xA23 ; P
        mov.b #0x01, &0xA24 ; .
        mov.b #0xFC, &0xA32 ; Q
        mov.b #0x02, &0xA33 ; Q (inner line)
        mov.b #0x88, &0xA2F ; )
        push.w R5 ; store original register value
        jmp titleScreenInput 

titleScreenInput: ; check s1.1 button presses
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     titleScreenDelay
        jmp     titleScreenInput
        
titleScreenDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal again to check if it was really pressed
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; it's no longer pressed and no long presses
        jeq     titleScreenInput        ; if S1 was NOT released after being pressed or wasn't really pressed correctly
        pop     R6
        mov     #2, &LCDCMEMCTL         ; clear screen
        ret
        
        
;============================================================================        
displayNamesLoopCall:
        push.w  R6                      ; used for button presses
        push.w  R8                      ; used for indexing names
        mov     #0,R8                   ; start at the first name
        jmp     displayNames

displayNames:
        mov     #2,LCDCMEMCTL
        cmp.b   #4, R8
        jeq     resetNameIndex
        mov.b   INDEX0_H (R8), &0xA29
        mov.b   INDEX0_L (R8), &0xA2A
        mov.b   INDEX1_H (R8), &0xA25
        mov.b   INDEX1_L (R8), &0xA26
        mov.b   INDEX2_H (R8), &0xA23
        mov.b   INDEX2_L (R8), &0xA24
        mov.b   INDEX3_H (R8), &0xA32
        mov.b   INDEX3_L (R8), &0XA33
        mov.b   INDEX4_H (R8), &0xA2E
        mov.b   INDEX4_L (R8), &0xA2F
        mov.b   INDEX5_H (R8), &0xA27
        mov.b   INDEX5_L (R8), &0xA28
        inc     R8
        jmp     displayNamesLoop        

resetNameIndex:
        clr     R8
        jmp     displayNames
        
displayNamesLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     displayNamesDelay 
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6          ; if S2 was pressed 
        jeq     releasedS2InDisplayNames         ;S2 was Pressed 
        jmp     displayNamesLoop        ; wasn't released

displayNamesDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if still holding it down: 
        jeq     displayNamesLoop        ; go back, keep checking for input
        jmp     displayNames            ; if it was released: then display next name

releasedS2InDisplayNames:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     displayNamesLoop        ; if still pressed, keep checking for input
        jmp     endDisplayNames         ; if released, stop displaying names. Go to next menu
 
endDisplayNames:
        pop     R8
        pop     R6
        mov     #2,LCDCMEMCTL
        ret
;===============================================================================
displaySignedScreenLoopCall:
        mov.b   #0xB7, &0xA29 ; S
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0x7C, &0xA23 ; U 
        mov.b   #0x00, &0xA24 ; 
        mov.b   #0xC1, &0xA32 ;?
        mov.b   #0x10, &0xA33
        mov.b   #0xB7, &0xA27
        mov.b   #0x00, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     signedInputLoop

signedInputLoop:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R6     
        and.b #00000110B, R6 ; bit mask on S1.1/2
        cmp.b #00000100B, R6 ; if S1.1 is pressed
        jeq signedS1P1Debounce
        mov.b &P1IN,R6
        and.b #00000110B, R6
        cmp.b #00000010B, R6 ; if S1.2 is pressed
        jeq signedS1P2Debounce
        jmp signedInputLoop ; continue to cycle for input

signedS1P1Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000100B,R6
        jeq     signedInputLoop                 ; if still pressed, keep checking
        jmp     SignedOrUnsignedCall            ; both operations for the signed subroutines end the same
        
signedS1P2Debounce:
        call    #delay
        mov.b   &P1IN,R6
        and.b   #00000110B,R6
        cmp.b   #00000010B,R6                   ; if still pressed
        jeq     signedInputLoop
        jmp     signedEnd                       ; both operations for the signed subroutines end the same

SignedOrUnsignedCall:
        mov.b   #0x00, &0xA27                   ; clear the S (default value)
        mov.b   #0x00, &0xA28
        jmp     SignedOrUnsigned
       
SignedOrUnsigned:
        cmp.b   #2,R8
        jeq     resetSignedIndex
        mov.b   SorU_H(R8),&0xA27
        mov.b   SorU_L(R8),&0xA28
        inc     R8
        jmp     signedInputLoop

resetSignedIndex:
        clr     R8
        jmp     SignedOrUnsigned
        
signedEnd:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;===============================================================================        
askConversion:
        mov.b   #0xF0, &0xA29           ;D
        mov.b   #0x50, &0xA2A
        mov.b   #0x00, &0xA25           ;>
        mov.b   #0x88, &0xA26
        mov.b   #0xF1, &0xA23           ;B
        mov.b   #0x50, &0xA24
        mov.b   #0xC1, &0xA32           ;?
        mov.b   #0x10, &0xA33
        mov.b   #0x00, &0xA2E
        mov.b   #0x00, &0xA2F
        mov.b   #0x00, &0xA27
        mov.b   #0xB0, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8 
        jmp     askConversionLoop
        
askConversionLoop:
        mov.b   &P1IN, R6               ; copy value of the input signal  
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6          ; if S1 was pressed (sets to 0 when pressed)
        jeq     askConversionDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InAskConversion          ;S2 was Pressed
        jmp     askConversionLoop        ; wasn't released

askConversionDelay:
        call    #delay
        mov.b   &P1IN, R6               ; copy value of the input signal to check if button was released after pressing
        and.b   #00000110B, R6          ; bit mask on S1.1
        cmp.b   #00000100B, R6
        jeq     askConversionLoop
        jmp     askConversionCall
        ret

releasedS2InAskConversion:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     askConversionLoop
        jmp     endAskConversion

askConversionCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     askConversionYN
        
askConversionYN:
        cmp.b   #2,R8
        jeq     resetIndex
        mov.b   YESNO_H(R8), &0xA27     ; Clear the N that was default value
        mov.b   YESNO_L(R8), &0xA28
        inc     R8
        jmp     askConversionLoop
        
resetIndex:
        clr     R8
        jmp     askConversionYN
        
endAskConversion:
        mov     R8,R4
        pop     R8
        pop     R6
        mov     #2,&LCDCMEMCTL
        ret       

;===================================================================================
HowManySelection:
        cmp     #0,R4
        jeq     HowManyEnd
        cmp     #1,R4
        jeq     askDecimalSpacesCall
        cmp     #2,R4
        jeq     HowManyEnd
        jmp     HowManyEnd

askDecimalSpacesCall:
        call    #askDecimalSpaces
        ret
        
HowManyEnd:
        mov     #2,LCDCMEMCTL
        ret
        
;====================================================================================
askDecimalSpaces:
        mov.b   #0x60, &0xA29; 1
        mov.b   #0x20, &0xA2A ; 1 (inner line)
        mov.b   #0x28, &0xA26 ; /
        mov.b   #0xDB, &0xA23 ; 2
        mov.b   #0xCB, &0xA32 ; ?
        mov.b   #0x60, &0xA27
        mov.b   #0x20, &0xA28
        push.w  R6
        push.w  R8
        mov     #1,R8
        jmp     decimalLoop

decimalLoop:
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6          ; check if you touched S1
        jeq     decimalDelay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     releasedS2InDecimal      ;check here if s2 wa pressed
        jmp     decimalLoop             ; loopyagain

decimalDelay:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000100B, R6
        jeq     decimalLoop
        jmp     decimalCall
        
releasedS2InDecimal:
        call    #delay
        mov.b   &P1IN, R6
        and.b   #00000110B, R6
        cmp.b   #00000010B, R6
        jeq     decimalLoop
        jmp     endDecimalSpace


decimalCall:
        mov.b   #0x00, &0xA27
        mov.b   #0x00, &0xA28
        jmp     decimalOneTwo

decimalOneTwo:
        cmp.b   #2, R8
        jeq     resetDecIndex
        mov.b   Dspace_H(R8), &0xA27 ;1 | 2
        mov.b   Dspace_L(R8), &0xA28
        inc     R8
        jmp     decimalLoop

resetDecIndex:
        clr     R8
        jmp     decimalOneTwo
        
endDecimalSpace:
        mov     #2, &LCDCMEMCTL
        pop     R8
        pop     R6
        ret

;==========================================================================================
        
delay:
        push.w  R7
        call    #delay2
        pop     R7
        ret
        
delay2:
        mov     #0xffff,R7
        jmp     next2
next2:
        dec     R7
        jnz     next2
        ret
        
programEnd:
        mov     #2, &LCDCMEMCTL
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        END
